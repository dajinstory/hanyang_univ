과제 수행 초반, cyclic Catmull-Rom spline curve로 생각하여 알파값을 0.5로 설정하여 수식을 작성했습니다.
과제 수행 도중 cyclic hermite Catmull-Rom spline curve로 구현한 친구들의 프로그램 동작모습을 보았습니다
(소스코드를 참고한 것이 아니라 동작하는 모습을 보았습니다.) 동작 모습이 친구들의 것이 .exe 파일로 주신 모범 답안과 더 비슷하다고 판단하여 spline curve 공식을 수정했습니다.
이전 방식 역시 주석을 해제하여 작동 모습을 보실 수 있습니다.

#UX/UI
.exe파일의 작동방식과 최대한 똑같이 만들었습니다. 

1. 첫 클릭 = 소를 선택
처음 프로그램을 실행할 경우, 소가 있는 박스를 클릭을 해야 이후 마우스의 움직임에 따라 소를 움직일 수 있게 됩니다.
처음 클릭된 위치가(화면상픽셀위치) 출력이 됩니다 "Left mouse click at (%d, %d)"
처음 클릭되었다는 표시가 push -1, inputState:0 등으로 출력이 됩니다.
처음 클릭이 소가 있는 박스 밖의 위치로 되는 경우 비정상적으로 작동하게 됩니다.
이후 처음 클릭한 위치로부터 상대적으로 픽셀이 어떻게 움직였는지 표시가 됩니다.

2. 두번째~일곱번째 클릭(총 여섯 번의 클릭)
마우스를 왼쪽을 누른 동작을 DOWN, 떼는 동작을 UP으로 표현하겠습니다.
UP 상태 이후 마우스를 드래그하는것을 HDRAG, 마우스가 DOWN인 상태에서 드래그하는 것을 VDRAG로 표현하겠습니다.

첫 클릭 이후 마우스는 HDRAG상태입니다. HDRAG상태의 경우 y벡터에 수직으로 이동이 가능합니다.
클릭하고 드래그할 경우 VDRAG상태가 되고, y벡터에 평행하게 이동이 가능해집니다.

DOWN을 하는 경우 클릭된 위치가 출력이 됩니다.
DRAG하는 과정이 매번 터미널에 출력이 됩니다. 또한 DOWN이후 UP할때까지, DOWN시점으로부터 마우스의 위치(픽셀위치)가 상대적으로 얼마만큼 변화했는지가 출력됩니다.
UP을 하는 경우 push, inputState정보가 출력이 되고, 해당 위치에 소가 나타납니다.

3. 일곱번의 클릭 이후
animation이 동작하게 됩니다.
사용자가 정한 6개의 위치를 소가 3바퀴 도는 것을 확인할 수 있습니다. 모두 도는 경우 소를 사라지게 했습니다.
(.exe파일의 경우 소가 다시 처음 고정된 위치로 돌아오지만 이후 동작에 따라 불규칙적인 모습을 보였기에, 해당 부분을 비슷하게 구현하지는 않았습니다)
소는 x축을 기준으로 회전하지 않고, 오직 y,z축으로만 회전하여 진행 방향을 바라보도록 했습니다. 내리막길에선 내려다 보고, 오르막길에선 올려다 봅니다. 좌우 방향이 바뀔경우 머리의 방향도 바뀌게 됩니다.
animation 동작 도중 클릭이 발생한 경우, 해당 지점에 소가 멈추고 이후 아무 동작도 하지 않는 것 역시 .exe파일과 동일하게 작성했습니다.


#수정부분
-전역변수
"#dajin" 밑에 넣은 부분은 제가 임의로 추가한 전역변수입니다.
UP하는 경우 해당 위치의 소가 추가되어야 하는데, fixed Points에 x,y,z좌표를 저장하는 식으로 추가했습니다.
numOfPoints는 현재 클릭된 횟수입니다. 첫 클릭의 경우 소와 마우스를 연결시키는 작업이기 때문에, 초기값을 -1로 설정했습니다.

showAnimation과 animStartTime은 animation이 동작하는 시점에 소의 위치를 지정하기 위한 변수입니다.
catMullRomCourse는 6x4의 2차원 배열인데, 6개의 점에서, 다음점과 잇는 함수를 3차원 함수로 표현했는데, 각각 t**3, t**2, t**1, t**0의 계수입니다.

firstCow2wld 2번째부터 7번째 클릭시 소를 화면에 하나씩 추가하는 것을 간단히 하기위해 제가 넣은 변수입니다.

cycle, pointIdx 는 animation도중 얼마만큼 진행되었는지 판단하기 위한 변수이고, NUM_OF_FRAME은 초반에 hermite가 아닌 CatMullRom 방식을 썼을떄 사용한 상수입니다.

x,z값의 변화가 없고, y값의 변화만 있는 동작을 하는 경우, 소의 머리방향이 바뀌는 것을 방지하기 위해, 이전 yaw값을 저장해두는 yaw_backup변수를 설정했습니다.

두번째부터 일곱번째 클릭동안 터미널에 픽셀 위치변화정보를 보여주기 위해 clicked_x, clicked_y 변수를 사용했습니다.

animation 동작 도중 클릭되었을때, animation을 멈추기 위해 stop_time, endAnimation 변수를 두었습니다.

새로 바꾼 Hermite CatMullRom 방식의 연산을 위해 matrixHermite과 matrixCatmullRom 행렬변수를 두었습니다.


-CatMullRomSpline(P, idx, nPoints)
6개의 점의 정보를 갖고있는 P와, 현재 시작점의 인덱스값을 갖는 idx를 통해 idx~(idx+1)%6 번째 점 사이의 함수를 만듭니다. t**3, t**2, t**1, t**0의 계수를 반환해줍니다.
주석처리 된 부분이 초기에 설정해둔 CatMullRom 방식입니다.

-rotateHRTF(current, nextPoint)
현재 위치와 바로 다음화면에 이동해야할 지점을 받아오고, 두 점의 차이를 써서 얻은 vector값에 따라 소의 머리방향을 이동시킵니다.

-setCatMullPoint
CatMullRomSpline함수를 써서, 6개의 점 사이의 수식정보를 얻습니다.

-getCatMullPoint
animation 동작 도중, 진행된 시간에 따라 현재 소가 있어야 할 점을 받아옵니다.

-display
animation 실행 전까지, 추가된 소가 화면에 나타나도록 했고, animation실행시에는, 소의 위치, 바라보는 방향등을 cow2wld에 수정하여 계속 출력하도록 했습니다.

-onMouseButton
animation 수행시 클릭 발생하는 경우 animation이 종료하도록 설정했습니다.
터미널에 출력이 계속 발생하게 했고, 점이 추가되는 과정이 들어가있습니다.

-onMouseDrag
터미널에 출력되는 내용이 있습니다.
HDRAG, VDRAG 각각에 대해서 소의 좌표가 변화하는 내용이 적혀있습니다.
HDRAG의 경우, x-clicked_x값이 0이상인경우, 0 미만인 경우에 따라 기준을 다르게 해서 측정했습니다.
x-clicked_x가 0보다 작거나 같은 경우(1,0,0)을 법선벡터로 갖는 평면하고의 접점에, z좌표를 수정하여, 현재 좌표로부터 위아래로 움직이도록 동작하게 했습니다.
반대로 0 이상인 경우, (0,0,1)을 법선벡터로 갖느 평면하고의 접점에, x좌표를 수정하여 현재좌표로부터 위아래로 움직이도록 동작하게 했습니다.




#Submission
a) 정상적으로 동작함을 확인했습니다.
b) L-drag, mouse move 모두 정상적으로 작동함을 확인했습니다.
c) 초기 cyclic Catmull-Rom spline curve를 사용해서 작성했고, 이후 hermite catmull rom 방식으로 수정해서도 정상적으로 작동함을 확인했습니다.
d) 앞을 바라보도록 했습니다.
e) 위아래 움직일 경우 해당 방향을 바라보도록 했습니다.